# Aktiviert den integrierten Webserver f√ºr Diagnose und OTA-Updates √ºber den Browser
web_server:
  port: 80 # Port, auf dem der Webserver erreichbar ist (Standard HTTP Port)

# Variablen, die im gesamten Konfigurationsfile wiederverwendet werden k√∂nnen
substitutions:
  name: "cosmo-box-3" # Interner Hostname des Ger√§ts
  friendly_name: "Cosmo AI" # Anzeigename f√ºr Home Assistant und Logs

# Grundlegende ESPHome Konfiguration
esphome:
  name: ${name} # Setzt den Hostnamen basierend auf der Substitution
  friendly_name: ${friendly_name} # Setzt den Anzeigenamen
  min_version: 2024.6.0 # Mindestversion von ESPHome, die zum Kompilieren ben√∂tigt wird
  name_add_mac_suffix: true # F√ºgt die letzten Stellen der MAC-Adresse an den Namen an, um Konflikte zu vermeiden
  on_boot:
    priority: -100 # Niedrige Priorit√§t, damit alles andere zuerst initialisiert wird
    then:
      - delay: 2s # Kurz warten bis alles bereit ist
      - output.turn_on: backlight # Display Backlight einschalten
      - delay: 3s
      - micro_wake_word.start: # Wake Word Erkennung starten
      - logger.log: "Cosmo ist bereit und h√∂rt auf das Wake Word!"

# Backlight Output (active low auf diesem Board)
output:
  - platform: gpio
    pin: 
      number: GPIO42
      inverted: true
    id: backlight

# Spezifische Einstellungen f√ºr den ESP32 Mikrocontroller
esp32:
  board: esp32-s3-devkitc-1 # Das verwendete Entwicklerboard (hier ein ESP32-S3)
  variant: esp32s3 # Die Chip-Variante (S3 ist leistungsst√§rker, gut f√ºr AI/Audio)
  framework:
    type: esp-idf # ESP-IDF Framework f√ºr micro_wake_word Support

# WLAN Konfiguration
wifi:
  ssid: !secret wifi_ssid # WLAN-Name aus secrets.yaml
  password: !secret wifi_password # WLAN-Passwort aus secrets.yaml
  # Fallback Access Point, falls keine Verbindung zum WLAN m√∂glich ist
  ap:
    ssid: "Cosmo Fallback Hotspot"

# Native API f√ºr die Kommunikation mit Home Assistant oder anderen Clients
api:
  # Passwort optional, f√ºr Sicherheit in Python-Skript nutzen
  password: "" # Hier leer gelassen, kann f√ºr Zugriffsschutz gesetzt werden

# Aktiviert das Logging √ºber USB (Serial) und WLAN
logger:
  level: DEBUG
  logs:
      micro_wake_word: DEBUG

# Over-The-Air Updates erm√∂glichen (Firmware-Updates √ºber WLAN)
ota:
  - platform: esphome

# --- AUDIO HARDWARE (SP-ESP32-S3-1.28-BOX mit ES8311) ---
# I2C f√ºr ES8311 Audio Codec
i2c:
  sda: GPIO15
  scl: GPIO14
  scan: true

# ES8311 Audio Codec (DAC + ADC)
audio_dac:
  - platform: es8311
    id: es8311_codec
    bits_per_sample: 16bit
    sample_rate: 16000
    mic_gain: 42dB  # Maximale Verst√§rkung f√ºr Wake Word

# Konfiguration des I2S Bus f√ºr Audio-Daten√ºbertragung
i2s_audio:
  - id: i2s_bus
    i2s_lrclk_pin: GPIO45  # WS/LRCK
    i2s_bclk_pin: GPIO9    # BCLK/SCLK
    i2s_mclk_pin: GPIO16   # MCLK

# Mikrofon Konfiguration (√ºber ES8311)
microphone:
  - platform: i2s_audio
    id: cosmo_mic
    i2s_audio_id: i2s_bus
    adc_type: external
    pdm: false
    i2s_din_pin: GPIO10
    channel: left
    bits_per_sample: 16bit
    sample_rate: 16000

# Lautsprecher Konfiguration (√ºber ES8311)
speaker:
  - platform: i2s_audio
    id: cosmo_speaker
    i2s_audio_id: i2s_bus
    dac_type: external
    i2s_dout_pin: GPIO8
    bits_per_sample: 16bit
    sample_rate: 16000
    channel: left
    audio_dac: es8311_codec

# Voice Assistant f√ºr Python TTS Streaming
voice_assistant:
  id: cosmo_voice
  microphone: cosmo_mic
  speaker: cosmo_speaker
  use_wake_word: false
  on_tts_stream_start:
    - logger.log: "üîä TTS Stream startet..."
    - micro_wake_word.stop:
  on_tts_stream_end:
    - logger.log: "üîä TTS Stream beendet"
    - delay: 500ms
    - micro_wake_word.start:

# RTTTL Buzzer f√ºr Test-T√∂ne
rtttl:
  id: rtttl_buzzer
  speaker: cosmo_speaker

# PA (Power Amplifier) einschalten
switch:
  - platform: gpio
    name: "Speaker Enable"
    id: pa_enable
    pin: GPIO46
    restore_mode: ALWAYS_ON

# Binary Sensor um Wake Word Status an Python zu senden
binary_sensor:
  - platform: template
    name: "Wake Word Detected"
    id: wake_word_detected
    on_press:
      then:
        - logger.log: "üîî Spiele Test-Ton..."
        - rtttl.play: "beep:d=4,o=5,b=100:c6"

# --- DISPLAY & SCHRIFT (SP-ESP32-S3-1.28-BOX) ---
# SPI Bus Konfiguration f√ºr das Display
spi:
  id: spi_bus
  clk_pin: GPIO4   # SCLK
  mosi_pin: GPIO2  # MOSI

# --- SCHRIFTEN ---
# Definition der verwendeten Schriftarten (werden von Google Fonts geladen)
font:
  - file: "gfonts://Roboto"
    id: font_normal # ID f√ºr normale Textgr√∂√üe
    size: 20 # Schriftgr√∂√üe in Pixeln
  - file: "gfonts://Roboto"
    id: font_small # ID f√ºr kleine Textgr√∂√üe
    size: 14 # Schriftgr√∂√üe in Pixeln

# --- DISPLAY ---
# Konfiguration des GC9A01 Displays (1.28" rund)
display:
  - platform: ili9xxx
    model: GC9A01A
    id: cosmo_display
    spi_id: spi_bus
    dimensions:
      height: 240
      width: 240
    cs_pin: GPIO5
    dc_pin: GPIO47
    reset_pin: GPIO38
    invert_colors: false
    update_interval: 1s
    # Lambda Funktion zum Zeichnen auf dem Display (C++ Code)
    lambda: |-
      // Hintergrund schwarz f√ºllen
      it.fill(Color::BLACK);
      
      // Augen zeichnen (Gelb) - F√ºr 240x240 rundes Display
      it.filled_circle(80, 90, 25, Color(0xFFFF00));   // Linkes Auge
      it.filled_circle(160, 90, 25, Color(0xFFFF00));  // Rechtes Auge
      
      // Texte anzeigen (zentriert f√ºr 240x240)
      it.printf(120, 160, id(font_small), Color(0x888888), TextAlign::CENTER, "%s", id(user_text).state.c_str());
      it.printf(120, 190, id(font_normal), Color(0xFFFFFF), TextAlign::CENTER, "%s", id(bot_text).state.c_str());
    
text_sensor:
  - platform: template
    name: "User Text"
    id: user_text
    update_interval: never # Wird nur manuell aktualisiert
  - platform: template
    name: "Bot Response"
    id: bot_text
    lambda: |-
          return {"Bereit"};
    update_interval: never # Wird nur manuell aktualisiert

# Binary Sensor um Wake Word Status an Python zu senden
binary_sensor:
  - platform: template
    name: "Wake Word Detected"
    id: wake_word_detected
    
micro_wake_word:
  microphone: cosmo_mic
  on_wake_word_detected:
    - logger.log: "üé§ WAKE WORD ERKANNT!"
    - binary_sensor.template.publish:
        id: wake_word_detected
        state: ON
    - delay: 500ms
    - binary_sensor.template.publish:
        id: wake_word_detected
        state: OFF
    - delay: 1s
    - micro_wake_word.start:  # Wake Word automatisch neu starten
  models:
    - model: okay_nabu
      probability_cutoff: 0.85  # H√∂her = weniger False Positives

# Debug: Regelm√§√üig Status loggen
interval:
  - interval: 10s
    then:
      - logger.log: 
          format: "üîä Mikrofon Status: micro_wake_word l√§uft"
          level: INFO