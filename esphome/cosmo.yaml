# Aktiviert den integrierten Webserver f√ºr Diagnose und OTA-Updates √ºber den Browser
web_server:
  port: 80 # Port, auf dem der Webserver erreichbar ist (Standard HTTP Port)

# Variablen, die im gesamten Konfigurationsfile wiederverwendet werden k√∂nnen
substitutions:
  name: "cosmo-box-3" # Interner Hostname des Ger√§ts
  friendly_name: "Cosmo AI" # Anzeigename f√ºr Home Assistant und Logs

# Grundlegende ESPHome Konfiguration
esphome:
  name: ${name} # Setzt den Hostnamen basierend auf der Substitution
  friendly_name: ${friendly_name} # Setzt den Anzeigenamen
  min_version: 2024.6.0 # Mindestversion von ESPHome, die zum Kompilieren ben√∂tigt wird
  name_add_mac_suffix: true # F√ºgt die letzten Stellen der MAC-Adresse an den Namen an, um Konflikte zu vermeiden
  on_boot:
    priority: -100 # Niedrige Priorit√§t = alles andere ist bereits initialisiert
    then:
      - output.turn_on: backlight
      - media_player.volume_set:
          id: cosmo_media_player
          volume: 75%
      - micro_wake_word.start:
      - logger.log: "üöÄ Boot: Display + Volume 75% + Wake Word aktiv"

# Backlight Output (active low auf diesem Board)
output:
  - platform: gpio
    pin: 
      number: GPIO42
      inverted: true
    id: backlight

# Spezifische Einstellungen f√ºr den ESP32 Mikrocontroller
esp32:
  board: esp32-s3-devkitc-1 # Das verwendete Entwicklerboard (hier ein ESP32-S3)
  variant: esp32s3 # Die Chip-Variante (S3 ist leistungsst√§rker, gut f√ºr AI/Audio)
  framework:
    type: esp-idf # ESP-IDF Framework f√ºr micro_wake_word Support

# Netzwerk - High-Performance DEAKTIVIEREN wegen fehlendem PSRAM!
network:
  enable_high_performance: false

# WLAN Konfiguration
wifi:
  ssid: !secret wifi_ssid # WLAN-Name aus secrets.yaml
  password: !secret wifi_password # WLAN-Passwort aus secrets.yaml
  # Fallback Access Point, falls keine Verbindung zum WLAN m√∂glich ist
  ap:
    ssid: "Cosmo Fallback Hotspot"

# Native API f√ºr die Kommunikation mit Home Assistant oder anderen Clients
# (Services sind unten definiert zusammen mit http_request)

# Aktiviert das Logging √ºber USB (Serial) und WLAN
logger:
  level: DEBUG
  logs:
      micro_wake_word: DEBUG

# Over-The-Air Updates erm√∂glichen (Firmware-Updates √ºber WLAN)
ota:
  - platform: esphome

# --- AUDIO HARDWARE (SP-ESP32-S3-1.28-BOX mit ES8311) ---
# I2C f√ºr ES8311 Audio Codec
i2c:
  sda: GPIO15
  scl: GPIO14
  scan: true

# ES8311 Audio Codec (DAC + ADC)
audio_dac:
  - platform: es8311
    id: es8311_codec
    bits_per_sample: 16bit
    sample_rate: 16000
    mic_gain: 42dB  # Maximale Verst√§rkung f√ºr Wake Word

# Konfiguration des I2S Bus f√ºr Audio-Daten√ºbertragung
i2s_audio:
  - id: i2s_bus
    i2s_lrclk_pin: GPIO45  # WS/LRCK
    i2s_bclk_pin: GPIO9    # BCLK/SCLK
    i2s_mclk_pin: GPIO16   # MCLK

# Mikrofon Konfiguration (√ºber ES8311)
microphone:
  - platform: i2s_audio
    id: cosmo_mic
    i2s_audio_id: i2s_bus
    adc_type: external
    pdm: false
    i2s_din_pin: GPIO10
    channel: left
    bits_per_sample: 16bit
    sample_rate: 16000

# Lautsprecher Konfiguration (√ºber ES8311)
speaker:
  - platform: i2s_audio
    id: cosmo_speaker
    i2s_audio_id: i2s_bus
    dac_type: external
    i2s_dout_pin: GPIO8
    bits_per_sample: 16bit
    sample_rate: 16000
    channel: left
    audio_dac: es8311_codec
    buffer_duration: 50ms  # Minimaler Buffer - spart RAM!
    timeout: 100ms  # Schnelleres Freigeben des I2S-Bus

# Media Player mit Speaker - kann URLs streamen!
media_player:
  - platform: speaker
    name: "Cosmo Media Player"
    id: cosmo_media_player
    announcement_pipeline:
      speaker: cosmo_speaker
      format: WAV
      sample_rate: 16000
      num_channels: 1
    buffer_size: 4000  # MINIMUM laut Doku (4KB)! Spart maximal RAM
    codec_support_enabled: false  # Nur WAV, kein MP3/FLAC - spart RAM
    on_announcement:
      - logger.log: "üì¢ Audio Announcement startet"
    on_idle:
      - logger.log: "‚úÖ Audio fertig - starte micro_wake_word sofort neu"
      - micro_wake_word.start:

# API - Services werden vom Media Player automatisch bereitgestellt
api:
  password: ""

# PA (Power Amplifier) einschalten
switch:
  - platform: gpio
    name: "Speaker Enable"
    id: pa_enable
    pin: GPIO46
    restore_mode: ALWAYS_ON

# Binary Sensor um Wake Word Status an Python zu senden
binary_sensor:
  - platform: template
    name: "Wake Word Detected"
    id: wake_word_detected
    on_press:
      then:
        - logger.log: "üîî Wake Word erkannt - warte auf TTS vom Python-Script"
        # Kein RTTTL Beep mehr - das kollidiert mit dem Media Player!
        # micro_wake_word wird bereits im on_wake_word_detected gestoppt

# --- DISPLAY & SCHRIFT (SP-ESP32-S3-1.28-BOX) ---
# SPI Bus Konfiguration f√ºr das Display
spi:
  id: spi_bus
  clk_pin: GPIO4   # SCLK
  mosi_pin: GPIO2  # MOSI

# --- SCHRIFTEN ---
# Definition der verwendeten Schriftarten (werden von Google Fonts geladen)
font:
  - file: "gfonts://Roboto"
    id: font_normal # ID f√ºr normale Textgr√∂√üe
    size: 20 # Schriftgr√∂√üe in Pixeln
  - file: "gfonts://Roboto"
    id: font_small # ID f√ºr kleine Textgr√∂√üe
    size: 14 # Schriftgr√∂√üe in Pixeln

# --- DISPLAY ---
# Konfiguration des GC9A01 Displays (1.28" rund)
display:
  - platform: ili9xxx
    model: GC9A01A
    id: cosmo_display
    spi_id: spi_bus
    dimensions:
      height: 240
      width: 240
    cs_pin: GPIO5
    dc_pin: GPIO47
    reset_pin: GPIO38
    invert_colors: false
    update_interval: 1s
    # Lambda Funktion zum Zeichnen auf dem Display (C++ Code)
    lambda: |-
      // Hintergrund schwarz f√ºllen
      it.fill(Color::BLACK);
      
      // Augen zeichnen (Gelb) - F√ºr 240x240 rundes Display
      it.filled_circle(80, 90, 25, Color(0xFFFF00));   // Linkes Auge
      it.filled_circle(160, 90, 25, Color(0xFFFF00));  // Rechtes Auge
      
      // Texte anzeigen (zentriert f√ºr 240x240)
      it.printf(120, 160, id(font_small), Color(0x888888), TextAlign::CENTER, "%s", id(user_text).state.c_str());
      it.printf(120, 190, id(font_normal), Color(0xFFFFFF), TextAlign::CENTER, "%s", id(bot_text).state.c_str());
    
text_sensor:
  - platform: template
    name: "User Text"
    id: user_text
    update_interval: never # Wird nur manuell aktualisiert
  - platform: template
    name: "Bot Response"
    id: bot_text
    lambda: |-
          return {"Bereit"};
    update_interval: never # Wird nur manuell aktualisiert
    
micro_wake_word:
  microphone: cosmo_mic
  stop_after_detection: true  # WICHTIG: Stoppt automatisch und gibt RAM frei!
  on_wake_word_detected:
    - logger.log: "üé§ WAKE WORD ERKANNT! (micro_wake_word stoppt automatisch)"
    - binary_sensor.template.publish:
        id: wake_word_detected
        state: ON
    - delay: 300ms
    - binary_sensor.template.publish:
        id: wake_word_detected
        state: OFF
  models:
    - model: okay_nabu
      probability_cutoff: 0.85